I'm using the README to just document my process here to get this app working.

To start, it looks like Spring has a quickstart initializer so I ran that with what looks like the latest stable release 4.0.3 and it generated me a zipfile that has the standard gradle setup including some dependencies and a latest version of java, which is 25.  One hiccup I ran into was that IDEA wasn't recognizing the installed JDK so I had to install one to my local home.  I suspect that this was because my IDEA is a flatpak install (my NetBeans had the same issue) but even when I used flatseal to extend permissions to /usr/lib/jdk it still didn't see the install dir, so I let that go for now since I needed to make progress on the rest.

At home I use Intellij so after unzipping the prebuilt project from the spring initializer, I opened the resulting project there and the gradle build script ran fine, so success there. After that I had to add a main application so I could start the server using gradle.  Adding this run step also let me run the server from inside the IDE so I could debug successfully. Here's where I saw the spring boot banner in the IDE and that verified I had tomcat running.

Next, I needed a main rest controller, so built a package “controllers” under com.gaggledemo and added a class RestController which would hold my endpoints.  For specialized endpoint groupings, I'd want more than just one class but for now, we can go with just one.

I did notice though that the default project didn't contain a critical import in the gradle.build, so I added 

implementation 'org.springframework.boot:spring-boot-starter-web'

And this allowed importing of @RestController and @GetMapping.  Since we were going to be using a DB, I chose to use SQLLite so I also added 

implementation 'org.xerial:sqlite-jdbc:3.51.2.0'

from the maven repo as my persistence choice.  I haven't used this DB before and for something a bit more larger scale, I'd probably go with Postgres just because I know it reasonably well and it's free, but SQLLite has an in-memory option and is used by a bunch of very highly rated apps (think web browsers and such) so it's going to be fine; besides jdbc makes persistence choices fairly flexible.  I also set up a /ping GET endpoint and after spinning up tomcat, I was able to hit this endpoint successfully using Bruno (kind of like Postman but I like it better)

At this point, since I had some workable code, it was time to set up git for a commit.  I already have a github account set up so I just created a new repo there named gaggledemo.  I've enabled the local project with git and was able to set up authentication between github and my IDE as well as command-line git using an expiring token and have tested all of that and everything has committed just fine.  I want to set git up with both IDEA and command-line because sometimes you need the flexibility of the command line to sort out when git misbehaves.

So, going back to the document, the next thing is to create some of the DDL for the DB, creating both tables.  I'm looking now more closely at sqllite and it's in-memory capability and according to the docs, even if it's in-memory, multiple connections can share the same in-memory DB if we use file::memory:?cache=shared structure in the jdbc url.  but, to test this, I think we can put together a little unit test and start to build out our test cases as well.

update: so SQLLite failed my across-connection test.  I've written the test and it did detect the failure however I could not get a jdbc url with the proper cross-connection sharing behavior.  Luckily I was able to just switch my dependency to the H2 db, update the jdbc URL to match the H2 format for cross-connection sharing and the test worked fine.  I'm not sure still how H2 fares with multiple connections going on at once but I think for now it should be ok.  Next I want to create a SQL file which contains the database structure - this will run before spring-boot init so any other stuff it needs to do will have the database support.

Next, I've created a startup SQL file to hold the schema to run before bootup, just to populate the empty DB and have also created a SQL Util class to help with this in some way.  The SQL file will just consist of statements separated by semi-colons and the parsing method in the util class will help with splitting that up since often, feeding in a file like this raw to jdbc will make it choke.  I'll also probably introduce comments in the file maybe with a single line // just so we can do some documentation on that file later on

Update: so it looks like a convenient way to document my progress is just to do a paragraph entry for each milestone like a diary, so that's what I'll do.  I've now created that schema file and put it into resources since it will need to be bundled with the app when it ships.  I've also introduced a SQLUtil app with corresponding tests so sql files can be parsed and will support // type commenting.  The tests pass so I think we're good to go.  Next step is to write a simple test that will create a throwaway DB and just run the schema to prevent any fatfingered SQL from getting into production.  At that point, I think we can do another git commit

I've now introduced more capability to SQLUtil which allows us to generate connections and run a list of SQL statements.  Also discovered a bug in the parser which let blank lines through so corrected that.  And as a result of the new unit test, found that the USER table is reserved so changed that table name to STUDENT.  But so far, I'm definitely liking H2, it's pretty easy to work with.  One thing I need to think about next is connection management and logging.  Based on how we already have a Util class to deal with connectivity, we may not need to use connection pooling yet but if we have time, that could come.

Another quick update: turns out that we've got logback bundled in with the spring boot so it was quick work to add some logging.  Running a few tests in the IDE confirmed that it was working fine.  I've used a nice construction in the LoggerFactory to pull in the dynamic class name via MethodHandles.  I can't forget the foreign key constraints in the schema.sql file, though.  That's probably next, then we can look at the ORM stuff I think.  

Ok, it's the next day and I'm now looking at the data layer.  I've created some named foreign key constraints on createdBy and editedBy into the student table and have run the associated test to ensure that the syntax was fine. Am looking at JPA next.

Ok, now for the JPA layer, I've created a data package in main and test so I can start creating things there.  I'm going to start just with the Student class since it has no foreign key constraints and can be created without anything else. I'm going to be doing some TDD here and start with a unit test.  And since I have an in-memory DB, I can create one in the test, populate it with data and try to look up the record using the ID.

The basic lookup test is now coded but I need the repository so I'm looking into that next.  I anticipate that I may have some issues in this test for my student record repository to use the connection as created and seeded by the unit test but we'll see.  It might be a good idea to either have a base class for our tests here or a util since we need to autopopulate the database with the data structure each time.

On second thought, I think we can have a createSchema method inside of SQLUtil to do this.  And later if there's time, we can build in some safety checks here just to make sure the schema isn't created twice.  Longer term, this can also be where versioning and in-place updating of the schema can take place.

Alright so I found out that there's resource files that can preload schemas and preload data for both the test and main environment.  I've gotten the schema loader to work but I don't have the test data working yet but I am able to have a simple student loading/ saving test working so that's progress.

I've cranked up the debugging in the logs up a bit and I'm seeing both the schema and the data.sql file running but I'm still not able to load that record.  I've put in spring.sql.init.mode=always into the application.properties to ensure that's always run but now I'm thinking this may actually be an issue with the way an in-memory DB is handled, the tests may be trashing the DB early?

Did more tweaking and broke the unit tests - I think this setup doesn't do well when there's a schema.sql in both main and test, that seems to be problematic.  And the schema isn't different between test and prod yet so I'm going to do one file now.  However, the issue with test data still is around, not sure what to do about that but when I use a file based DB, it does work, so there's definitely issues with in-memory persistence in unit tests right now.  But seeing as we have to test the full CRUD cycle which will include data creation, it's not a big obstacle for right now. Oh and I also found out that the schema.sql file doesn't like // comments so switched it to /* */ style instead, which still works with my old schema test code.  I can move on to the next step but will commit a working codebase now before we get there.

Alright, so next we should look at creating some endpoints for CRUD with users.  I also noticed that the spec says we have to have User as the object name, not Student, so I will probably update that next before I get too far.  However, the only issue is that H2 already has a predefined USER table. Going to add SqlSquirrel to my machine so I can do some manual querying and get a good naming for the table that more matches USER.

Ok, so now sql squirrel is up and running with an in-memory DB, operates fine and as I thought, user is a keyword.  Maybe I can slightly reword this to AppUser and do and alternative table name mapping in the ORM layer or as an alternative, the table USERS (plural) is actually ok to use.  I was thinking to keep the table name as Student but that's a bit too confusing and if it also contains academic staff, Student isn't actually accurate.    So that will have to change regardless.

At this point, I feel like User is a bit too generic and there are not only keywords like this in H2 but also potentially other objects, so I'm going to rebill this entire structure as AppUser / APP_USER.  It's not exactly what's written but will cause less confusion in the long run

Ok, since we're early in the dev cycle, this change wasn't tough to do especially with refactoring tools, so we did the change and all the tests pass again. Committing and next work is endpoints for AppUser

In terms of the endpoints, I want to use the HTTP methods to control what the endpoints do so POST will create new and GET will search by ID or list all.  This project is getting long, so rather than doing a bunch more around this data element, I should move to Document after that.  I think I'll be creating some DTOs and then using auto-rendering to turn that to and from JSON.  When a new AppUser is created, the caller needs the ID back so maybe I'll return the entire DTO back to them just as verification in the response.

Alright, lots done as of this point.  A simple service layer has been created for AppUsers and that's autowired into the Requesthandler.  Then I made a POST which creates a user as well as two types of GETs, one which lists all users and one that looks up by ID.  Additionally, there's some simple validation inside of the request handler via some annotations in the incoming request DTO and an exception handler which can give back validation errors if they come up.  Finally, I had to decide on how to convert an incoming DTO to an entity data object so I introduced a builder pattern, which worked well.  So now the service uses a builder to pull all of the fields from the incoming DTO into the entity for saving.  All in all, a lot of work done in this session so it's time to commit again.

